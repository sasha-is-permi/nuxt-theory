<!-- 
Nuxt.js
Понадобится Visual studio code и плагин Vetur для проверки.

https://nuxtjs.org

Расширяет возможности vue.js .
Из коробки предоставляет возможности сервер-сайт рендеринга.

https://nuxtjs.org/guide/installation

В visual studio code:

1) Установить create-nuxt-app
npm i -g create-nuxt-app

Перейти в папку с проектами.
/* на сайте рекомендуется:
npm init nuxt-app <project-name>
*/

create-nuxt-app nuxt-theory

Project name, description- просто enter

Use a custom server framework: 
Может использовать разные сервера- например, express.
Если пишем none- nuxt.js   использует собственный сервер.

Choose features to install 
Дополнительные модули. Пока ничего не выбираем. 

Use a custom UI fraimwork -
выбираем bootstrap, vuetify или none. 
Выберем none. 

Тестовый фреймворк: выберем none.
Choose rendering mode
> Universal (выберем)Servise set rendering будет работать
SPA (для обычного динамического сайта)

Author Enter

Packet meneger: npm

Запускаем проект: npm run dev
На localhost:3000 
доступен проект. 

В package.json:

В зависимости- nuxt
Нет vue, vue-router, vuex - они входят в ядро nuxt


dev - для разработки приложения

build- создание итогового production- приложения


  To get started:

        cd nuxt-theory
        npm run dev

  To build & start for production:

        cd nuxt-theory
        npm run build
        npm run start


  start- запускает build-версию, чтобы она работала. 
  
  Для работы ssr (если его выбрали)
  нужно чтобы был запущен и сервер и клиент. 
  build start это и делает. 

  generate- генерирует статические страницы в build если используем spa

  2. Структура приложения. 

  Папки:

  Структура папок важна.
  
  nuxt- служебная информация. 
  
  assets-   sass или js некомпилированные файлы там будут 
  
  components- обычные компоненты на vue.js 

   Layout: 
   компоненты первоочередные.

  nuxt- куда рендерить страницу.
  Похоже на router технологию vue 

  middleware- рассмотрим в отдельном уроке. 

pages:  
Как главная страница
index.vue

Импортируем для неё из components/about.vue 
import Logo '@/components/Logo.vue'
или
import Logo '~/components/Logo.vue'

@ или ~ - импорт из корня папки. 

node_modules - дополнительные модули

plugins - плагины


static- статические файлы типа favicon.ico и т.п
картинки

store- тут будем организовывать хранение данных vuex

nuxt.config.js 

Сначала загружаем файл package.json (require),
 далее экспортируем js-объект, у которого есть набор конфигураций. 

 mode: 'universal' - используем ssr. 
 head: фактически index.html тут

 


<template>
  <div>
    <Nuxt />
  </div>
</template>

Респозиторий:
https://github.com/sasha-is-permi/nuxt-theory


// надо представиться если не представлялись. Один раз после создания проекта
// Информация записывается в .git/config
git init // создает git/config
git config --local user.name "Alexandr"         - имя пользователя для проекта
git config --local user.email sasha-is-permi@mail.ru         - e-mail


// После создания или изменения файлов в проекте
git add -A
git commit -m "first commit"

// Только первый раз при создании.
// Информация записывается в .git/config
git remote add origin https://github.com/sasha-is-permi/nuxt-theory
// Посылаем файлы проекта на github
// В следующий раз можно посылать файлы более простой командой:
// git push
git push -u origin master


loading- отвечает за загрузку страниц (для серверной загрузки)

build - изменяем build-конфигурацию.

Расширяем функционал webpack (клиентская сторона построенна на webpack)

3. Создание разметки приложения. 

Установим bootstrap 

npm install bootstrap 

В nuxt.config.js прописать если нет: 

css: [
 '@/node_modules/bootstrap/dist/css/bootstrap.min.css'
]



pages: index.vue 
Убираем лишнее. 

layout: 
(сначала идет layout, затем страницы)

Тоже очищаем.

 <template>
  <div class="container">
    <Nuxt />
  </div>
</template>

<style>

</style>



Создаем новый компонент navbar.vue. 

После скачивания на другой компьютер 
(git clone:
git init
git name
git email
npm install
npm run dev
)

2.4 Статические роуты.

navbar.vue: 
обеспечивает переход по страничкам

<nav class="navbar navbar-expand-sm bg-light">


  <ul class="navbar-nav">
    <li class="nav-item">
      <nuxt-link class="nav-link" to="/">Home</nuxt-link>
    </li>
    <li class="nav-item">
       <nuxt-link class="nav-link" to="/users">Users</nuxt-link>
    </li>
    <li class="nav-item">
      <nuxt-link class="nav-link" to="/about">About</nuxt-link>
    </li>
  </ul>

</nav>
1)
Роуты создаем по другому чем во vue.
Создаем файлы в определенной структуре. 

Если нет ничего в адресной строке (home page):
nuxt загружает index.vue
Это главная страница. 

В папке pages создаем users.vue. 
Это обычный vue-компонент. 

В этом файле:
<template>
  <section>
     <h1> Users page </h1>
  </section>
</template> 

Этого достаточно чтобы появилась страница
localhost:3000/users

2) Нужно создать страничку About в папке pages. 
Создаем папку About, в ней index.vue

Подключить sass-предпроцессор:
npm install --save-dev sass sass-loader 
(или при установке проекта)

(для vue:
npm i node-sass sass-loader)

Можно использовать:
<style lang="scss" scoped>
h1 {
  text-align:center;
}

</style>

В navbar.vue: 

<nuxt-link> 
по анологии с <vue-link>
- делает так чтобы страничка не перезагружалась при переходе по ссылке. 

Вместо <a href=""> используем <nuxt-link to="">

Теперь переходим в динамическом режиме как в SPA

5. Динамические роуты и валидация. 

Можем использовать 

data () {
return {}
}

Но можем использовать и стрелочную функцию:

  data: () => ({
    users: [
      1, 2, 3, 4, 5
    ]
  })

В users.vue: 

<template>
  <section>
    <h1>Users page</h1>
    <div class="menu">
    <ul>

      Выводим список из элементов массива 
      <li v-for="user of users" :key="user">
        При клике переходим без перезагрузки страницы на другую 
        страничку- с User (goTO(user)- метод, описанный ниже)
        <a href="#" @click.prevent="goTo(user)">User {{user}}</a>
      </li>
    </ul>
    </div>
  </section>
</template>

<script>
export default {
  data: () => ({
    users: [
      1, 2, 3, 4, 5
    ]
  }),
  methods: {
    // Программная (динамическая) навигация.
    // программно определяем что нужно переходить на страничку
    // users/1
    goTo(user) {
      this.$router.push('/users/' + user)
    }
  }
}
</script>

<style lang="scss" scoped>
h1 {
  text-align:center;
}

.menu{
  display:flex;
  justify-content:center;
}

</style>

Чтобы создать еще страничку, на которую переходить-
в папке Users должен быть файл _id.vue :

<template>
  <h1>User with id {{$route.params.id}}</h1>
</template>

<script>
export default {
  validate({params}) {
    return /^\d+$/.test(params.id)
  }
}
</script>


Это будет шаблон странички, 
на которую можно переходить. 

Этот файл является роутом, который откликается на динамический параметр
(user.id)

nuxt будет передавать во vue router параметр id. 

{{$route.params.id}} - это число, приходящее из users.vue, 
массив user, текущий user (пункт меню, соотваетствующий текущему user)

validate- метод, которым nuxt расширяет instanse vue: 
регулярное выражение- должны быть только числа. 
Применяем его (test) к params.id -значение переданной страницы
params- объект типа {id:2}

  validate({params}) {
    return /^\d+$/.test(params.id)
  }

{params} - достаем поле с параметрами из контекста.

Валидируем (проверяем) заход на данную страничку. 


2.6 


Ссылки и обработка ошибок. 
В navbar.vue: 
Тому элементу li, который является активным- передаем class="active"

Nuxt упрощает:
Для nav-link: 
добавляем active-class="active" 

 exact для главной ссылки- home подсвечивается только тогда когда
 активна. 

navbar.vue: 

<template>
  <header>
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
      <a class="navbar-brand" href="#">NuxtJS</a>

      <div class="collapse navbar-collapse" >
        <ul class="navbar-nav mr-auto">
          <li class="nav-item">
            <nuxt-link exact active-class="active" class="nav-link" to="/">Home</nuxt-link>
          </li>
          <li class="nav-item">
            <nuxt-link no-prefetch active-class="active" class="nav-link" to="/users">Users</nuxt-link>
          </li>
          <li class="nav-item">
            <nuxt-link active-class="active" class="nav-link" to="/about">About</nuxt-link>
          </li>
        </ul>
      </div>
    </nav>
  </header>
</template>


no-prefetch- подгружать страницу не сразу
(во vue "ленивая загрузка")

Для обработки ошибок захода на страницу:
в папке layouts создаем файл error.vue (зарезервированное имя). 

<template>
  <section>
    <h1>Error 404</h1>
    <nuxt-link :to="'/'">Home</nuxt-link>
  </section>
</template>

<style scoped>
  h1 {
    color: red;
  }

  section {
    display: flex;
    align-items: center;
    flex-direction: column;
  }
</style>

2.7 Как работают Layouts. 

В каталоге pages/users создаем файл  login.vue: 

<template>
  <form>
    <h1>Login</h1>

    <div class="form-group">
      <input type="text" class="form-control">
    </div>

    <div class="form-group">
      <input type="password" class="form-control">
    </div>

    <p>
      <nuxt-link to="/">Home</nuxt-link>
    </p>

    <button class="btn btn-primary">Login</button>
  </form>
</template>

<script>
export default {
  layout: 'empty'
}
</script>


<style scoped>
  form {
    width: 600px;
  }
</style>


Создается форма, используя bootstrap: 
в файле login.vue. 

Затем в navbar.vue подключаем ссылку на страницу. 

<li class="nav-item">
     <nuxt-link no-prefetch active-class="active" class="nav-link" to="/login">Login</nuxt-link>
</li>

(тоже используем "ленивую загрузку") no-prefetch

Хотим при загрузке страницы логин ее содержимое показывать по-центру, 
другие пункты меню не показывать. 

Создаем в layouts empty.vue с содержимым:

<template>
  <div class="container">
    <nuxt />
  </div>
</template>

<style scoped>
  .container {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding-top: 5rem;
  }
</style>


Чтобы создать свой layout 
для страницы login: 

<script>
export default {
  layout: 'empty'
}
</script>


(по умолчанию- default)

Т.е. фактически используем шаблон 
empty.vue для login.vue . 

В login.vue возврат обратно на главную страницу: 

<p>
  <nuxt-link to="/">Home</nuxt-link>
</p>

2.8 Что такое модули. 

Описание модулей nuxt:
https://github.com/nuxt-community/awesome-nuxt

Пример: описание как работать с модулем axios:
https://axios.nuxtjs.org/

Позволяет делать удобные ajax-запросы.

npm install @nuxtjs/axios


Вручную только редактируем
nuxt.config.js 


export default {
  modules: [
    '@nuxtjs/axios',
  ],

  axios: {
    // proxy: true
  }
}

А в package.json и в node_modules axios добавляется автоматически: 

"dependencies": {
    "@nuxtjs/axios": "^5.12.3",
    "bootstrap": "^4.3.1",
    "cross-env": "^5.2.0",
    "nuxt": "^2.4.0"
  }

2.9 Asunc Data. 
Как Nuxt работает с данными. 

Vue
Посылаем запрос на сервер, ждем, получаем данные. 

Nuxt. 
При использовании SSR сначала готовим данные на сервере, 
а только потом возвращаем пользователю. 

asyncData() - вызывается на серверной части 
(до того как страничка отобразится). 

Эмулируем асинхронный запрос через promice:
asyncData должен возвращать promise:

Перенесем массив users из data()
в asyncData. 

А в data() - локальные данные, 
которые будем использовать на frontend.

  asyncData() {
    return new Promise(resolve => {
      setTimeout(() => {
        resolve({
          users: [
            1, 2, 3, 4, 5
          ]
        })
      }, 3000)
    })
  },
  data() {
    return {
      pageTitle: 'Users page'
    }
  }

В результате на клиент приёдет и массив users, 
и pageTitle.

При переходе на страничку users данные получаются 
с задержкой 3 сек. 
(поскольку там есть setTimeout )


В nuxt.config.js: 

делаем индикатор загрузки синий. 
  loading: { color: 'blue' },

Если не обновится- перезапускаем приложение.


В users _id.vue добавляем: 
Можем загрузить какого-то конкретного
пользователя:
<h1>{{user.name}}</h1>
Если заходим пункт меню- выводится номер меню.

asyncData({params, error}) {
    return new Promise((resolve) => {
      setTimeout(() => {
         resolve({
           user: {
             name: `Test user ${params.id}`
           }
         })
      }, 1500)
    })
  }

  Чтобы вызвало ошибку при заходе на страницу: 


    asyncData({params, error}) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        reject(error(new Error('User not found')))
        // resolve({
        //   user: {
        //     name: `Test user ${params.id}`
        //   }
        // })
      }, 1500)
    })
  }

 2.10
 Async data на практике. 

 сервис для работы с данными по REST API
 https://jsonplaceholder.typicode.com

 JSON файл получим:
 https://jsonplaceholder.typicode.com/users


 В pages/users/index.vue делаем асинхронный запрос: 
 // делаем get-запрос с того адреса, где json-файл

   asyncData({$axios, error}) {
    return $axios.$get('https://jsonplaceholder.typicode.com/users')
      .then(users => {
        return {
          users
        }
      })
      .catch(err => {
        error(err)
      })
  }

  В asyncData не имеет доступа к this-
  только работаем с контекстом.
  Полученный объект users трансформируем в users,
  который будем использовать внутри компонента
  
  Применение axios возвращает promise. 
  При ошибке- вызываем error, получаемый из контекста.

  Используем полученные с сервера данные:
   <ul>
  <li v-for="user of users" :key="user.id">
    <a href="#" @click.prevent="goTo(user)">{{user.name}} ({{user.email}})</a>
  </li>

  В методах переходим по id пользователя: 

  methods: {
    goTo(user) {
      this.$router.push('/users/' + user.id)
    }
  }


Модифицируем шаблон для захода на страницу в конкретном меню
(_id.vue):

<template>
  <div>
    <h1>{{user.name}}</h1>
    <hr />
    <b>{{user.email}}</b>
  </div>
</template>

<script>
export default {
  validate({params}) {
    return /^\d+$/.test(params.id)
  },
  async asyncData({params, error, $axios}) {
    try {
      const user = await $axios.$get(`https://jsonplaceholder.typicode.com/users/${params.id}`)
      return {user}
    } catch (e) {
      error(e)
    }
  }
}
</script>

Получаем определенного user по его id. 

2.11 Работа с vuex. 

Заходим в папку store, создаем файл, отличный от index.js
Nuxt будет счмитать это модулем vuex. 
Создаем файл users.js. 
Сдесь можно экспортировать state,mutations,actions,getters 


Создаем action,  позволяющим грузить данные:

export const actions = {
  // асинхронный метод
  async fetchUsers() {
    try {
      // Получаем объект "пользователи" с помощью асинхронного запроса axios
      const users = await this.$axios.$get('https://jsonplaceholder.typicode.com/users')
      return users
    } catch (e) {
      throw e // говорим об ошибке
    }
  }
}

блок try...catch -  чтобы не было необработанных ошибок. 

Теперь в users/index.vue обращаемся не к axios а к store:

export default {
  async asyncData({store, error}) {
    try {
      // с помощью await дожидаемся объект users из store
      const users = await store.dispatch('users/fetchUsers')
      return {users}
    } catch (e) {
      error(e) // если есть ошибка- выводим её методом error()
      (layout error)
    }
  },


  Меняем код в store/user.js: 

 export const actions = {
  async fetchUsers({commit}) {
    try {
      const users = await this.$axios.$get('https://jsonplaceholder.typicode.com/users')
      commit('setUsers', users)
    } catch (e) {
      throw e
    }
  },

  // Для получения отдельного пользователя по id
  async fetchUserById({}, userId) {
    try {
      return await this.$axios.$get(`https://jsonplaceholder.typicode.com/users/${userId}`)
    } catch (e) {
      throw e
    }
  }
}

export const getters = {
  users: state => state.users
}
 
Используя store, теперь получаем страничку конкретного пользователя
(раньше также получали, просто не вызывая store)

В users/_id.vue: 

  async asyncData({params, error, store}) {
    try {
      const user = await store.dispatch('users/fetchUserById', params.id)
      return {user}
    } catch (e) {
      error(e)
    }
  }

  Передаем id пользователя в store, вызываем 
  action из srore fetchUserById, а в ответ получаем информацию о пользователе user

  Будем загружать информацию о пользователях один раз, а не каждый раз. 
  Загрузим все в state. 

  Константа будет функцией, возвращающей объект. 
  В store/user.js: 

  export const state = () => ({
  users: []
})

  Создаем mutation для изменения users
export const mutations = {
  setUsers(state, users) {
    state.users = users
  }
}


Создаем геттер:


export const getters = {
  users: state => state.users
}

// Принимаем commit чтобы получить доступ до mutation 
// и изменить state:

export const actions = {
  async fetchUsers({commit}) {
    try {
      const users = await this.$axios.$get('https://jsonplaceholder.typicode.com/users')
      commit('setUsers', users)
    } catch (e) {
      throw e
    }
  }


В users/index.vue создаем computed-свойство для обращения к геттерам:

  computed: {
    users() {
      return this.$store.getters['users/users']
    }

Вместо asyncData вызываем метод fetch():

  async fetch({store, error}) {
    try {
      if (store.getters['users/users'].length === 0) {
        await store.dispatch('users/fetchUsers')
      }
    } catch (e) {
      error(e)
    }
  }

  Разница- ничего не возвращаем из данного метода
  (в asyncData пришлось бы возвращать пустой объект)
  Просто вызываем по dispatch() нужный нам action. 

  Чтобы загрузить массив пользователей только 1 раз: 

   if (store.getters['users/users'].length === 0) {
        await store.dispatch('users/fetchUsers')
      }

  Если еще не загрузили- подгружаем. 

  2.13  Moddleware и защита роутов. 

  Модифицируем страничку about/index.vue:

  <template>
  <section>
    <h1>About page</h1>

    <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Impedit, omnis.</p>

    <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Quibusdam reprehenderit, corrupti recusandae quae ducimus consectetur.</p>
  </section>
</template>

<script>
export default {  
  middleware: ['auth']
}
</script>


Организуем систему, с помощью которой будем логиниться в приложение. 

В login.vue:

<template>
  При вызове нажатии на кнопку отправки отменяем стандартное действие 
  и вызываем метод onSubmit

  <form @submit.prevent="onSubmit">
    <h1>Login</h1>

    <div class="form-group">
      <input type="text" class="form-control">
    </div>

    <div class="form-group">
      <input type="password" class="form-control">
    </div>

    <p>
      <nuxt-link to="/">Home</nuxt-link>
    </p>

    <button class="btn btn-primary" type="submit">Login</button>
  </form>
</template>

<script>
export default {
  layout: 'empty',
  methods: {
    onSubmit() {
      // вызываем метод "login" из store 
      this.$store.dispatch('login')

      this.$router.push('/')
    }
  }
}
</script>


<style scoped>
  form {
    width: 600px;
  }
</style>

// При вызове dispatch() не указали путь типа 'users/fetchUsers'
// значит обращаемся к store/index.js 

export const actions = {

  
  // Создаем 2 actions: 
  login и logout

  login({commit}) {
     // Вызываем с помощью метода commit mutation setToken(). Передаем ему значение "true" 
    commit('setToken', 'true')
  },
  logout({commit}) {
    // Разлогиниваемся
    commit('clearToken')
  }
}

export const state = () => ({
  token: null
})

export const mutations = {
  setToken(state, token) {
    state.token = token
  },

  // logOut
  clearToken(state) {
    state.token = null
  }
}

export const getters = {
  // Приводим к boolean-значению state.token
  isAuth: state => !!state.token
}


navbar.vue: 

<template>
  <header>
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
      <a class="navbar-brand" href="#">NuxtJS</a>

      <div class="collapse navbar-collapse" >
        <ul class="navbar-nav mr-auto">
          <li class="nav-item">
            <nuxt-link exact active-class="active" class="nav-link" to="/">Home</nuxt-link>
          </li>
          <li class="nav-item">
            <nuxt-link no-prefetch active-class="active" class="nav-link" to="/users">Users</nuxt-link>
          </li>
          <li class="nav-item">
            <nuxt-link active-class="active" class="nav-link" to="/about">About</nuxt-link>
          </li>
          <li class="nav-item">
            <nuxt-link no-prefetch active-class="active" class="nav-link" to="/login">Login</nuxt-link>
          </li>
          <li class="nav-item" v-if="isAuth">
            <a class="nav-link" href="#" @click.prevent="logout">Logout</a>
          </li>
        </ul>
      </div>
    </nav>
  </header>
</template>

<script>
export default {
  computed: {
    isAuth() {
      return this.$store.getters.isAuth
    }
  },
  methods: {
    logout() {
      this.$store.dispatch('logout')
    }
  }
}
</script>


Меняем navbar.vue: 


<template>
  <header>
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
      <a class="navbar-brand" href="#">NuxtJS</a>

      <div class="collapse navbar-collapse" >
        <ul class="navbar-nav mr-auto">
          <li class="nav-item">
            <nuxt-link exact active-class="active" class="nav-link" to="/">Home</nuxt-link>
          </li>
          <li class="nav-item">
            <nuxt-link no-prefetch active-class="active" class="nav-link" to="/users">Users</nuxt-link>
          </li>
          <li class="nav-item">
            <nuxt-link active-class="active" class="nav-link" to="/about">About</nuxt-link>
          </li>
          <li class="nav-item">
            <nuxt-link no-prefetch active-class="active" class="nav-link" to="/login">Login</nuxt-link>
          </li>
           Если пользователь авторизированн- показываем ссылку logout
          <li class="nav-item" v-if="isAuth">
            Вызываем Logout При клике на кнопку Logout            
            <a class="nav-link" href="#" @click.prevent="logout">Logout</a>
          </li>
        </ul>
      </div>
    </nav>
  </header>
</template>

<script>
export default {
  // Авторизированны или нет
  // ссылку logout имеет смысл показывать только если пользователь авторизированн
  computed: {
    isAuth() {
      return this.$store.getters.isAuth
    }
  },
  methods: {
    logout() {
      this.$store.dispatch('logout')
    }
  }
}
</script>


Защитим страничку (роут) Auth:
Создаем middleware/auth.js:

export default function({store, redirect}) {
  // Если авторизация не прошла - возвращаемся к окошку ввода логина
  // (пользователь переходит на страницу логина)
  if (!store.getters.isAuth) {
    redirect('/login')
  }
}

Принимаем store 
В store есть геттер, отвечающий за авторизацию. 
Можно применить isAuth 


На страничке about/index.vue 
применяем соданный middleware 
(их можно несколько использовать. Они будут вызываться по очереди- слева направо)

<script>
export default {
  middleware: ['auth']
}
</script>


2.14  NuxtServerInit. 

Сделаем так, чтобы список пользователей 
загружался сначала. 
Сначала подгрузился- потом доступен.
Раньше было- открыли страницу Users- загрузился список. 
Только 1 раз загружается. 

Сейчас будет- при открытии любой страницы в начале работы программы- 
загружается список пользователей 1 раз, сохраняется в store. 
Потом он отобразится на страничке Users.


pages/users/index.vue - меняем
Метод fetch закомментируем 

Переходим в store/index.js 

Применяем метод:
Он вызывается на серверной части когда nuxt 
начинает свою работу.

// Вызываем action fetchUsers из модуля Users
// Данный метод является асинхронным
// поэтому используем async... await

async nuxtServerInit({dispatch}) {
  await dispatch('users/fetchUsers')
}

3. Front-end. Создание блога

3.1 Создание проекта. 

https://nuxtjs.org

create-nuxt-up  

https://github.com/nuxt/create-nuxt-app/blob/master/README.md

Новый вариант
npx create-nuxt-app <project-name>
npm init nuxt-app <project-name>

старый вариант  
create-nuxt-app <project-name>

На github:

Make sure you have npx installed (npx is shipped by default since npm 5.2.0)

npx create-nuxt-app <my-project>


Or starting with npm v6.1 you can do:
npm init nuxt-app@latest <my-project>


Features
Package manager
Yarn
Npm  *

Programming language
JavaScript *
TypeScript

UI framework:
None (feel free to add one later) 
Ant Design Vue
BalmUI
Bootstrap  или *
Buefy
Bulma
Chakra UI
Element    или * (element ui)
Framevuerkb
iView
Tachyons
Tailwind CSS
Vuesax
Vuetify

Nuxt.js modules:
Axios - Promise based HTTP client  *
Progressive Web App (PWA)
Content - Git-based headless CMS

Linting tools:
ESLint *
Prettier
Lint staged files
StyleLint
Commitlint

Testing framework:
None  *
Jest
AVA
WebdriverIO
Nightwatch

Rendering mode
Universal (SSR / Static)  *
SPA

Deployment target
Server (Node.js hosting) *
Static (Static/JAMStack hosting)

Development tools
jsconfig.json  *
Semantic PR
Dependabot (for GitHub only)

Continous Integration
GitHub Actions  *

(Bootsrap- есть еще bootstrap vue- другая утилита bootstrap.
Чтобы не перепутать- можно при установке не выбирать bootstrap, 
установить потом:
Установим bootstrap 

npm install bootstrap 

В nuxt.config.js прописать если нет: 

css: [
 '@/node_modules/bootstrap/dist/css/bootstrap.min.css'
]



)


В проекте в данном случае:
Use custom site freimwork- в прошлые разы выбирали none (встроенный 
сервер nuxt, сейчас выбираем express)

Nuxt JS + SSR. Подробное руководство (2020 год)
https://www.youtube.com/watch?v=RheGRnLNSSc
npx create-nuxt-app test-nuxt


3.2 Настройка проекта. 

Удаляем лишнее. 

~ или @ указывает в пути на корень проекта 

Плагин element-ui переименовываем в globals, указываем 
русский язык.

import Vue from 'vue'
import Element from 'element-ui'
import locale from 'element-ui/lib/locale/lang/ru-RU'

Vue.use(Element, { locale })

nuxt.config.js :

  plugins: [
    '@/plugins/globals'
  ],


   content: pkg.description

  имеется в виду поле из package.json:  description

Сейчас имеется "чистый" проект на nuxt

3.3 Создание layout

Создадим собственный layout на основе element ui
https://element.eleme.io/#/en-US


https://element.eleme.io/#/en-US/component/container

<template>
  <el-container>
    <el-header>
      Тут используем подключенный через javascript компонент navigation.vue . 
      Получается- сверху - этот компонент, ниже выводятся pages 
      <app-navigation />
    </el-header>
    Это элементы из фреймврока Elements UI
    Тут будем выводить странички и pages
    (  <nuxt /> - обеспечивает вывод (рендеринг)
    страничек)
    <el-main>
      <nuxt />
    </el-main>
    <el-footer />
  </el-container>
</template>

<script>
import AppNavigation from '@/components/main/Navigation'

export default {
  components: {
    AppNavigation
  }
}
</script>


<style>

</style>


npm install --save-dev sass sass-loader
( Или в текущем курсе совет по установке:
npm i -D node-sass sass-loader   )


Подключаем navigation.vue: 

<template>
  <nav>
    <h1>SSR Blog</h1>
  </nav>
</template>

<style lang="scss" scoped>
  nav {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    border-bottom: 1px solid #e6e6e6;
  }
</style>

Создадим тему в паплчке theme
index.scss:


* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  font-family: 'Helvetica Neue',Helvetica,'PingFang SC','Hiragino Sans GB','Microsoft YaHei',SimSun,sans-serif;
  font-weight: 400;
  -webkit-font-smoothing: antialiased;
}

Затем в nuxt.config.js подключаем данный файл: 

  css: [
    'element-ui/lib/theme-chalk/index.css',
	'@/theme/index.scss'
    ]
    
   В этом файле можно задавать стили для всего приложения. 


   3.4  Главная страница. 

   В pages:  index.vue выводим список всех постов 

  В данном фреймворке elements ui: 

  xs <768 px
  sm >=768 px
  md >=992 px
  lg >=1200px
  xl >]1920 px






<template>
  На сайте фреймворка Elements UI
  Components/Layout: 
   можно задать атрибуты типа type: 

  <el-row type="flex" justify="center">
  
    По умолчанию при экране xs тег будет занимать 24 колонки
    байдинг ":" - чтобы показать что мы передаем 24 как число 
    иначе-строка

    <el-col :xs="24" :sm="18" :md="12" :lg="10">
      в цикле выводим посты с помощью компонента app-post (Apppost)
      <app-post
        v-for="post in 3"
        :key="post"
      />
    </el-col>
  </el-row>
</template>

<script>
import AppPost from '@/components/main/Post'
export default {
  // это получается заголовок вверху страницы
  head: {
    title: 'Главная'
  },
  components: {
    AppPost
  }
}
</script>

<style>

</style>

Импортируем файл components/main/post.vue  как Apppost
и используем его (выше)


post.vue: 
(шаблон поста) 
Для компонентов реккомендуется добавлять собственный префикс, 
например Apppost

<template>
  <article class="post">

  </article>
</template>

<script>
export default {
  
}
</script>

<style lang="scss" scoped>
  .post {
    height: 200px;
    border: 1px solid black;
    margin-bottom: 2rem;
  }
</style>


3.5  Компонент пост. 
Дорабатываем компонент "Пост": 
Компонент Card из elements ui: 



<template>
  <el-card

Атрибуты карточки card: 
затенение- при наведении (на сайте фреймворка это свойство описанно)
     shadow="hover"
стиль : отступов нет (можно и так передавать что отступов нет)     
    :body-style="{padding: 0}"
    class="post"
  >
    <header slot="header" class="post-header">
     
      Название поста
      <h3>Post title</h3>


      <small>
        в elements ui а поиске icon: 
        таким образом иконку выводим
        <i class="el-icon-time"></i>
        Приведение даты к строковому виду
        {{ new Date().toLocaleString() }}
      </small>
    </header>
    <div class="post-body">
      <img 
        src="https://cdn.tripzaza.com/ru/destinations/files/2017/09/Berlin-e1505798693967.jpg" 
        alt="post image" 
        class="post-img"
      >
    </div>
    <footer class="post-footer">
      В components UI button: 
      el-button

      round  - передаем round="true"
      При клике на кнопку- вызываем метод openPost 
      <el-button round @click="openPost">Открыть</el-button>

      <span>
        изображение конвертика
        <i class="el-icon-message"></i>

        12
      </span>
    </footer>
  </el-card>
</template>

<script>
export default {
  methods: {
    openPost() {
      console.log('Open post')
    }
  }
}
</script>

<style lang="scss" scoped>
  отступ от поста
  .post {
    margin-bottom: 1.5rem;
  }

  разносим по разные стороны
  .post-header {
    display: flex;
    justify-content: space-between;
    align-items: center; по вертикали по центру
  }

  .post-img {
    зпнимает всю ширину, по высоте центрируем
    width: 100%;
    height: auto;
  }

  В footer разносим по разные 
  стороны элементы, центрируем по вертикали
  и делаем отступы 
  .post-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem;
  }
</style>

3.6  Страница детального отображения.
Функционал для кнопочки "Открыть" пишем + регистрируем 
новый роут. 

адресная строка:
localhost:3000/post/34

34- считываемый id поста

в папке pages создаем папку post - это новый route 


В адресной строке создается динамически страница с id- адрес поста
Создаем в папочке _id.vue 

<template>
  <article class="post">
    <header class="post-header">
      <div class="post-title">
        <h1>Post title</h1>
        Тег с картинкой - стрелочка обратно. 
        При нажатии на него- переход обратно на главную страничку. 
        <nuxt-link to="/">
          <i class="el-icon-back"></i>
        </nuxt-link>
      </div>
      <div class="post-info">
        <small>
          <i class="el-icon-time"></i>
          {{ new Date().toLocaleString() }}
        </small>
        <small>
          картинка и число (число просмотров данного поста)
          <i class="el-icon-view"></i>
          42
        </small>
      </div>
      <div class="post-image">
        <img 
          src="https://cdn.tripzaza.com/ru/destinations/files/2017/09/Berlin-e1505798693967.jpg" 
          alt="post image"
        >
      </div>
    </header>
    <main class="post-content">
      <p>Lorem, ipsum dolor sit amet consectetur adipisicing elit. Autem veritatis accusantium voluptatibus accusamus quos doloremque ut in distinctio, quam delectus?</p>
      <p>Lorem, ipsum dolor sit amet consectetur adipisicing elit. Autem veritatis accusantium voluptatibus accusamus quos doloremque ut in distinctio, quam delectus?</p>
      <p>Lorem, ipsum dolor sit amet consectetur adipisicing elit. Autem veritatis accusantium voluptatibus accusamus quos doloremque ut in distinctio, quam delectus?</p>
    </main>
    <footer>

    </footer>
  </article>
</template>

<script>
export default {
  валидируют параметры: params- параметры, содержащиеся в адресной строке
  validate({params}) {
    если есть id в строке параметров- можем показывать страницу и она будет валидная
    если нет params.id- вернется false. 
    В таком случае не сможем вернуть страницу. 

    return Boolean(params.id)
  }
}
</script>

<style lang="scss" scoped>
  .post {
    max-width: 600px;
    margin: 0 auto;
  }

  .post-title {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
  }

  .post-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: .5rem;
  }

  .post-image img {
    width: 100%;
    height: auto;
  }

  .post-header {
    margin-bottom: 1.5rem;
  }

  .post-content {
    margin-bottom: 2rem;
  }
</style>

Чтобы настроить открытие страницы в components/.. post.vue: 
При открытии вызывается метод Openpost
Динамически создается страничка с указанным путем
(переходим на новый создаваемый роут)
В папочке post вызвается _id.vue и обрабатывается переданный ${id}:

<script>
export default {
  methods: {
    openPost() {
      const id = 'test-id'
      Создаем динамически страничку с указанным путем
      id передаем в _id.vue - для обработки id в динамически создаваемой странице
      (_id.vue- для динамически создаваемых страниц, 
      папочка about с index.vue- для странички about, файл login.vue в корне pages-
      для странички login) 
      // в дальнейшем вместо id будем передавать this.post.id
      this.$router.push(`/post/${id}`)
    }
  }
}
</script>


3.7  Обработка ошибки роутов. 

При попадении на страничку несуществующую- ошибка. 
Создадим страничку для краствой обработки этой ошибки. 

В папке layouts создаем error.vue. 
Он будет отрабатывать когда есть какая-то ошибка. 

<template>
  <div class="error-layout">
    <div class="error-content">
      <h1 class="error-title">Ошибка 404</h1>
      При ошибке- ссылка возврата на главную страничку 
      <nuxt-link to="/">Вернуться на главную</nuxt-link>
    </div>
  </div>
</template>

<style lang="scss" scoped>
  .error-layout {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
  }

  .error-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding-top: 4rem;
  }

  .error-title {
    color: rgb(145, 6, 6);
    margin-bottom: 1rem;
  }
</style>


3.8 Список комментариев. 

Для списка всех комментариев: 
pages\post\_id.vue

    <footer>
    
      Проверяем- есть или нет комментарии
           
      <div class="comments" v-if="true">
        в цикле вызываем компонент app-comment
        <app-comment
         на каждой иттерации создаем переменную comment
         передаем параметр comment в компонент app-comment
         со значением 'comment'
        v-for="comment in 4"
          :key="comment"
          // 
          :comment="comment"
        />
      </div>

   
      <div class="text-center" v-else>Комментариев нет</div>
    </footer>

В script импортируем содержимое из comments.vue и создаем 
новый тег <app-comment>:
 
  <script>

    Подключим и зарегистрируем компонент    

import AppComment from '@/components/main/Comment'
export default {
  validate({params}) {
    return Boolean(params.id)
  },
  components: {AppComment}
}
</script>



Добавляем также components/main/comment.vue: 




<template>
  <el-card class="comment">
    <div class="comment-header">
      <span>Person name</span>
      <span>
        <i class="el-icon-time"></i>
        {{ new Date().toLocaleString() }}
      </span>
    </div>
    <div class="comment-text">
      Lorem ipsum dolor sit amet.
    </div>
  </el-card>
</template>

<script>
export default {
  // входящий параметр comment забираем из другого
  // компонента который его экспортирует. 

  props: ['comment']
}
</script>

<style lang="scss" scoped>
  .comment {
    margin-bottom: 1rem;
  }

  .comment-header {
    display: flex;
    justify-content: space-between;
    margin-bottom: 0.5rem;
    font-size: 0.8rem;
  }

  // Сохраняем
  .comment-text {
    white-space: pre-line;
  }
</style>

Класс text-center- зададим в корневом scss-файле. 

Props: 

  	В app.vue:

  <appCar
  Передаем параметры carName и carYear со значениями, заданными ниже:
  carName: 'Ford',    carYear: 2018  в компонент appCar (зарегистрирован как appCar компонент car.vue в app.vue)

	:carName="carName"
	:carYear="carYear"
	>

   Не экспортируем, а задаем значения
   export default {
   data () { 	return {    carName: 'Ford',    carYear: 2018 }   }
                  }
	


	
    В car.vue:
    Принимаем значения из другого компонента с помощью props
    (значение передается из app.vue с помощью использования тега
      <appCar>, которым назван car.vue)

    export default {
	props:['carName','carYear']
	               }

3.9 Форма добавления комментариев

Компонент для добавления комментариев для поста: 
Components/main/CommentForm.vue 


<template>
  <el-form
    значения, которые вводятся в поля формы 
    :model="controls"
    добавляем правила валидации- массив определен ниже. 
    это на сайте elements ui в главе про формы
    :rules="rules"
    ref="form"
    // нативный метод submit- прослушка для всей формы
    // (можно и на конкретную кнопку повесить событие, или на всю форму)
    // prevent-  отменяем стандартное действие
    // Вызываем метод onSubmit


    @submit.native.prevent="onSubmit"
  >
    <h1>Добавить комментарий</h1>
    name- связанно с полем conrols.name  двухсторонним связыванием  
    <el-form-item label="Ваше имя" prop="name">
      двухстороннее связывание input и переменной. trim удаляет пробелы
      <el-input v-model.trim="controls.name" />
    </el-form-item>

    <el-form-item label="Текст комментария" prop="text">
      <el-input
        type="textarea"
        v-model.trim="controls.text"
        resize="none"
        :rows="2"  // показываем 2 строчки текстового поля
      />
    </el-form-item>

    <el-form-item>
      <el-button
        type="primary"
        тип кнопки. Это на сайте elements ui/form  
        эти аттрибуты описанны
        native-type="submit"
        round
      >
        Добавить комментарий
      </el-button>
    </el-form-item>
  </el-form>
</template>

<script>
export default {
  data() {
    return {
      controls: {
        name: '',
        text: ''
      },
      правила валидации 
      триггер blur- при потере фокуса (оставлении поля) валидация
      можно добавить еще элемент массива: 
      { min: 3, max: 5, message: 'Длина должна быть от 3 до 5', trigger: 'blur' }

      rules: {
        name: [
          { required: true, message: 'Имя не должно быть пустым', trigger: 'blur' }
        ],
        text: [
          { required: true, message: 'Введите ваш комментарий', trigger: 'blur' }
        ]
      }
    }
  },
  methods: {
    // отправляем только валидные комментарии
    // этот текст скопировали с сайта фреймворка elements ui
    onSubmit() {
      (форму назвали в заголовке формы- ref="form")
      this.$refs.form.validate(valid => {
        if (valid) {
          // Если форма валидна
          console.log('Form is Valid')
        }
      })
    }
  }
}
</script>


<style lang="scss" scoped>

</style>

В динамической странице формирования поста: pages\_id.vue: 

импортируем компонент по созданию формы:
import AppCommentForm from '@/components/main/CommentForm'

Регистрируем: 
export default {
  validate({params}) {
    return Boolean(params.id)
  },
  components: {AppComment, AppCommentForm}
}

Используем: 
 <footer>
      <app-comment-form />
 ...
 </footer>

 На сайте Elements UI: 
 компонент Form. 

3.10 Валидация и логика для добавления комментария

Редактируем файл commentForm.vue: 

<template>
  <el-form
    :model="controls"
    :rules="rules"
    ref="form"
    @submit.native.prevent="onSubmit"
  >
    <h1>Добавить комментарий</h1>

    <el-form-item label="Ваше имя" prop="name">
      <el-input v-model.trim="controls.name" />
    </el-form-item>

    <el-form-item label="Текст комментария" prop="text">
      <el-input
        type="textarea"
        v-model.trim="controls.text"
        resize="none"
        :rows="2"
      />
    </el-form-item>

    <el-form-item>
      <el-button
        type="primary"
        native-type="submit"
        round
        // связываем аттрибут с переменной
        :loading="loading"
      >
        Добавить комментарий
      </el-button>
    </el-form-item>
  </el-form>
</template>

<script>
export default {
  data() {
    return {
      загрузка данных не идет пока- кнопка "Добавит комментарий" активна
      loading: false,
      controls: {
        name: '',
        text: ''
      },
      rules: {
        name: [
          { required: true, message: 'Имя не должно быть пустым', trigger: 'blur' }
        ],
        text: [
          { required: true, message: 'Введите ваш комментарий', trigger: 'blur' }
        ]
      }
    }
  },
  methods: {
    onSubmit() {
      this.$refs.form.validate(valid => {
        if (valid) {
          // свойство из element ui
          // если true- кнопка блокируется, идет как бы загрузка 
          // данных формы на сервер
          this.loading = true
          
          // данные для отправки на сервер- собираем из полей формы
          const formData = {
            name: this.controls.name,
            text: this.controls.text,
            postId: ''
          }

          try {
            setTimeout(() => {
              // Сначала сообщение, а потом $emit
              // ($emit будет при событии created вызывать метод из _id.vue:
              //     @created="createCommentHandler"

              // на сайте elemenst ui- у инстанса vue благодаря этому фреймворку
              // появляется новый метод, благодаря которому можкм выводить красивые сообщения 
              this.$message.success('Комментарий добавлен')
              // $emit связывает родительский компонент и дочерний. 
              // при событии created (создание- что-то делаем)
              this.$emit('created')
            }, 2000)
          } catch (e) {
            //
            this.loading = false
          }
        }
      })
    }
  }
}
</script>


<style lang="scss" scoped>

</style>



Редактируем метод, в котором добавляем форму
(pages/form/id.vue)
<template>
  <article class="post">
    <header class="post-header">
      <div class="post-title">
        <h1>Post title</h1>
        <nuxt-link to="/">
          <i class="el-icon-back"></i>
        </nuxt-link>
      </div>
      <div class="post-info">
        <small>
          <i class="el-icon-time"></i>
          {{ new Date().toLocaleString() }}
        </small>
        <small>
          <i class="el-icon-view"></i>
          42
        </small>
      </div>
      <div class="post-image">
        <img
          src="https://cdn.tripzaza.com/ru/destinations/files/2017/09/Berlin-e1505798693967.jpg"
          alt="post image"
        >
      </div>
    </header>
    <main class="post-content">
      <p>Lorem, ipsum dolor sit amet consectetur adipisicing elit. Autem veritatis accusantium voluptatibus accusamus quos doloremque ut in distinctio, quam delectus?</p>
      <p>Lorem, ipsum dolor sit amet consectetur adipisicing elit. Autem veritatis accusantium voluptatibus accusamus quos doloremque ut in distinctio, quam delectus?</p>
      <p>Lorem, ipsum dolor sit amet consectetur adipisicing elit. Autem veritatis accusantium voluptatibus accusamus quos doloremque ut in distinctio, quam delectus?</p>
    </main>
    <footer>
      <app-comment-form
      // если комментарий еще не добавлен- добавляем его
        v-if="canAddComment"
        В этом методе добавим комментарий к существующему списку,
        а также скроем форму.
        Прослушиваем событие "created"
         (компонент создан, но еще не заложен в dom-дерево)

        @created="createCommentHandler"
      />

      <div class="comments" v-if="true">
        <app-comment
          v-for="comment in 4"
          :key="comment"
          :comment="comment"
        />
      </div>
      <div class="text-center" v-else>Комментариев нет</div>
    </footer>
  </article>
</template>

<script>
import AppComment from '@/components/main/Comment'
import AppCommentForm from '@/components/main/CommentForm'

export default {
  validate({params}) {
    return Boolean(params.id)
  },
  data() {
    return {
      // Пользователь, который зайдет на страничку впервые, 
      // сможет добавлять комментарии
      canAddComment: true
    }
  },
  methods: {
    createCommentHandler() {
      // комментарий уже добавлен
      this.canAddComment = false
    }
  },
  components: {AppComment, AppCommentForm}
}
</script>

<style lang="scss" scoped>
  .post {
    max-width: 600px;
    margin: 0 auto;
  }

  .post-title {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
  }

  .post-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: .5rem;
  }

  .post-image img {
    width: 100%;
    height: auto;
  }

  .post-header {
    margin-bottom: 1.5rem;
  }

  .post-content {
    margin-bottom: 2rem;
  }
</style>

Можно в коде написать ключевое слово "debugger"- попадем 
в дебаггер, там можно посмотреть значения переменных. 

3.11 
Анимация при изменении страниц

Плавный переход при смене страниц. 
Это касается vue, nuxt. 

Добавим базовую анимацию. Для этого воспользуемся 

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  font-family: 'Helvetica Neue',Helvetica,'PingFang SC','Hiragino Sans GB','Microsoft YaHei',SimSun,sans-serif;
  font-weight: 400;
  -webkit-font-smoothing: antialiased;
}

.text-center {
  text-align: center;
}
// Когда заходим на страницу и когда 
// покидаем страницу
.page-enter-active, .page-leave-active {
  // прозрачность анимируем 0.4 сек.
  transition: opacity .4s;  // тут страница непрозрачная
  // имеется в виду конечное значение opacity:1. 
  // Это по умолчанию, можно не писать.
}

.page-enter, .page-leave-active {
  opacity: 0; // сначала страница полностью прозрачная
}

4. Front-end. Панель администратора. 

4.1 Создание структуры страниц

Для создания layout: 
https://element.eleme.io/#/en-US/component/container

В папочке layout новый файл: admin.vue:


<template>
  <div class="admin-layout-wrap">
    высота блока- 100%
    <el-container :style="{height: '100%'}">
      <el-aside width="200px">
        Aside
      </el-aside>
      <el-main>
        Сюда будем рендерить страницу
        <nuxt />
      </el-main>
    </el-container>
  </div>
</template>

<script>
export default {

}
</script>

<style lang="scss" scoped>
  на всю ширину и высоту основной блок
  .admin-layout-wrap {
    width: 100%;
    height: 100vh;
  }
</style>

В папке pages создаем папку admin. 
Будет роут admin (страничка) - административная панель.
В нем файл index.vue. 

<template>
  <h1>Welcome to admin page</h1>
</template>

<script>
export default {
  layout: 'admin' // используем шаблон (layout) admin
}
</script>


4.2  Меню навигации. 
Компонент, позволяющий делать навигацию внутри админки. 
Импортируем компонент из components\admin\aside.vue 
в файле components\layout\admin.vue

Это меню слева

components\layout\admin.vue:
<template>
  <div class="admin-layout-wrap">
    <el-container :style="{height: '100%'}">
      <el-aside width="250px">
        <app-aside />
      </el-aside>
      <el-main>
        <nuxt />
      </el-main>
    </el-container>
  </div>
</template>

<script>
import AppAside from '@/components/admin/Aside'

export default {
  components: {AppAside}
}
</script>

<style lang="scss" scoped>
  .admin-layout-wrap {
    width: 100%;
    height: 100vh;
  }
</style>


(для страницы localhost://admin (она в pages/admin
указан этот layout))

Создаем меню слева
(components\admin\aside.vue)

Nav menu описанно: 
https://element.eleme.io/#/en-US/component/menu


<template>
  <el-menu
    router  // Параметр router в меню element ui- каждый пункт меню будет являться ссылкой.
    :style="{height: '100%'}" //вертикальное меню на всю страничку- чтобы 
    :default-active="$route.path" // активный пункт меню в element ui (чтобы его подсвечивать)
    текущий пункт меню определяется тем, на какой странице мы находимся ($route.path -
    системная переменная vue, и исходя из этого выделяется цветом).
    С помощью пунктов меню можно перейти на подстраничку, системная переменная изменится и подсветка
    активного пункта меню изменится. 
  >
    <el-menu-item index="/admin">  //  /admin/index.vue
      <i class="el-icon-menu"></i>
      <span>Аналитика</span>
    </el-menu-item>
    <el-menu-item index="/admin/create">  // admin/create.vue
      <i class="el-icon-edit-outline"></i>  // с сайта element ui/icon - выбираем картинки для элементов меню
      <span>Создать</span>
    </el-menu-item>
    <el-menu-item index="/admin/list">
      <i class="el-icon-tickets"></i>
      <span>Посты</span>
    </el-menu-item>
    <el-menu-item index="/admin/user">
      <i class="el-icon-service"></i>
      <span>Пользователи</span>
    </el-menu-item>
    <el-menu-item index="/admin/logout">
      <i class="el-icon-setting"></i>
      <span>Выйти</span>
    </el-menu-item>
  </el-menu>
</template>

Так роутинг организованн в nuxt. 
Когда ссылаемся на localhost:3000/admin/list 
переходим в pages/admin/list.vue автоматически. 
(или admin/list/index.vue нужно делать)


Для каждой созданной страницы добавляеуи админский layout, 
чтобы меню не терялось

<script>
export default {
  layout: 'admin'
}
</script>

4.3  Страница логина. 

Создаем файл: pages\login\login.vue: 

<template>
  <el-card
    shadow="always" затенение - всегда
    :style="{width: '500px'}"  - ширину задаем окна
  >
    <el-form
      :model="controls"
      :rules="rules"
      ref="form"
      @submit.native.prevent="onSubmit"
    >
      <h2>Войти в панель администратора</h2>

      <el-form-item label="Логин" prop="login">
        <el-input v-model.trim="controls.login" />
      </el-form-item>

      <div class="mb2">
        <el-form-item label="Пароль" prop="password">
          <el-input v-model.trim="controls.password" type="password" />
        </el-form-item>
      </div>

      <el-form-item>
        <el-button
          type="primary"
          native-type="submit"
          round
          :loading="loading"
        >
          Войти
        </el-button>
      </el-form-item>
    </el-form>
  </el-card>
</template>

<script>
export default {
  layout: 'empty',
  data() {
    return {
      loading: false,
      controls: {
        login: '',
        password: ''
      },
      rules: {
        login: [
          { required: true, message: 'Введите логин', trigger: 'blur' }
        ],
        password: [
          { required: true, message: 'Введите пароль', trigger: 'blur' },
          { min: 6, message: 'Пароль должен быть не менее 6 символов', trigger: 'blur' }
        ]
      }
    }
  },
  methods: {
    onSubmit() {
      console.log('submit')
    }
  }
}
</script>

Используем шаблон (layout) empty.vue: 

<template>
  <div class="empty-layout">
    <nuxt />
  </div>
</template>

<style lang="scss" scoped>
  .empty-layout {
    display: flex;
    justify-content: center;
    width: 100%;
    padding-top: 4rem;
  }
</style>

Перейти к логину:
http://localhost:3000/admin/login


4.4  Создание авторизации с vuex. 

login.vue: при отправке формы вызывается метод onSubmit()
      Обращаемся к форме:       
      this.$refs.form.validate(async valid => {
        если форма валидна:
        if (valid) {
          // переменная: загрузка- идет
          this.loading = true
          эмуляция отправки post-запроса на сервер      
          try {
            создаем новый объект, записываем туда значения, считанные из полей формы
            const formData = {
              login: this.controls.login,
              password: this.controls.password
            }
            // используем асинхронную функцию- ждем авторизацию... 
            // Чтобы использовать await нужно выше написать:
            // async valid  
            await this.$store.dispatch('auth/login', formData)
            // если все успешно (try блок)- переходим на страничку admin
            this.$router.push('/admin')

          } catch (e) {
            // для ошибок- сделаем общую шину.          
            this.loading = false // если ошибка- прекращаем загрузку
          }
        }
      })


    Nuxt vuex: 
    https://ru.nuxtjs.org/docs/2.x/directory-structure/store/

    vuex по умолчанию идет с nuxt,  отдельно подключать его не надо. 

    Ещё ссылка на описание:
    https://nuxtjs.org/guide/vuex-store

    store/ auth.js
    Файл отвечает за авторизацию: 

  state записываем как функцию- форма записи в nuxt. 
  token-  переменная, которая будет приходить с сервера. 
  Если есть token- проверяем на валидность- отправляем на backend. 
  Нет токена- значит не авторизованны. 


    export const state = () => ({
  token: null
})

export const mutations = {
  setToken(state, token) {
    // Принимаем token с сервера, 
    // изменяем тот token, который в state.
    state.token = token
  }
}

export const actions = {
  асинхронная функция. Принимает 2 метода.
  Эмулируем работу с сервером. Вызываем 
  метод resolve() через 2 сек.
  async login({commit, dispatch}, formData) {
    const token = await new Promise(resolve => {
      возаращаем в token значение 'mock-token', которое приходит с сервера
      setTimeout(() => resolve('mock-token'), 2000)
    })
    // вызываем action setToken
    // dispatch вызывает action
    dispatch('setToken', token)
  },
  // вызываем mutation setToken
  // commit обращается к mutation
  setToken({commit}, token) {
    commit('setToken', token)
  }
}

export const getters = {
  // getter isAuthenticated: 
  // принимает state, затем с помощью стрелочной функции 
  // преобразуем к булевскому значению и возвращаем его
  // state.token- пришло какое-то значение с сервера-true (авторизованно),
  // пустой- false (не авторизовано)
   

  isAuthenticated: state => Boolean(state.token)
}


Экспортируем из модуля - такая форма записи в nuxt для vuex. 

В login.vue: 
   await this.$store.dispatch('auth/login', formData)
   Вызываем из модуля auth метод (action) login, 
   передаем ему formData- введенные данные.    
  
  В блоке ошибок: 
  console.log('e',e)
  Вывод ошибки. 

  Для анализа ошибки в коде:
  Пишем слово debugger в текте, 
  Выходим на ошибку. 

  vuex chrome extention 
  (vue devtools- инструмент chrome дополнительный)

  Посмотреть код/ на вкладочке vue сможем отслеживать state. 


  4.5  Защита роутов с middleware. 

  Добавим функционал, защищающий роуты в админке. 
  Чтобы неавторизованный пользователь не мог на них заходить. 

  В папке middleware: 
  admin-auth.js: 
                              context
  export default function({store, redirect}) {
    если пользователь не залогинен (обращаемся к геттеру)
  if (!store.getters['auth/isAuthenticated']) {
    // функция в nuxt. Переходим на страницу login
    // используем get-параметр message=login
    redirect('/admin/login?message=login')
  }
}

Подключаем данный middleware ко всем страницам, которые хотим защитить. 
Может быть несколько middleware в списке, важен порядок. 

Папочка admin:
меняем файлы
create,list,logout,user

export default {
  layout: 'admin',
  middleware: ['admin-auth']
}

В login.vue метод mounted() -подключается когда dom-дерево готово для работы. 
created- вызывется и на сервере и на клиенте. 
Тут нужно вызывать метод, который на клиенте только вызывается. 

// Если переданный параметр 'login'- поясняем- что сначала надо войти в систему.
mounted() {

    получаем get-параметр 'message' из адресной строки
    const {message} = this.$route.query

    if (message === 'login') {
    // выводим сообщение
      this.$message.info('Для начала войдите в систему')
    }
  }


4.6  Завершение сессии. 

Страница logout: должна вызвать action для очистки данных в store, 
затем выполнить redirect на другую страницу. 


logout.vue: 

<template>
  <div>Очищаем данные</div>
</template>

<script>
export default {
  layout: 'admin',
  middleware: ['admin-auth'],
  до создания инстанса vue, т.е. в начале загрузки страницы
  beforeCreate() {
    вызываем action logout из store. Очищаем token в store
    this.$store.dispatch('auth/logout')
    Делаем редирект на страницу login. Добавляем get-параметр чтобы страница login вывела сообщение-
    предложение залогиниться
    this.$router.push('/admin/login?message=logout')
  }
}
</script>


В store   auth.js :
(очищаем token)

export const mutations = {
  setToken(state, token) {
    state.token = token
  },
  clearToken(state) {
    очищает state
    state.token = null
  }
}

export const actions = {
  async login({commit, dispatch}, formData) {
    const token = await new Promise(resolve => {
      setTimeout(() => resolve('mock-token'), 2000)
    })
    dispatch('setToken', token)
  },
  setToken({commit}, token) {
    commit('setToken', token)
  },
  logout({commit}) {
    вызываем очистку state
    commit('clearToken')
  }
}


В login.vue: 
Получает get-параметр message: 

    switch (message) {
      case 'login':
        this.$message.info('Для начала войдите в систему')
        break
      case 'logout':
      // success- сообщение другим цветом
        this.$message.success('Вы успешно вышли из системы')
        break
    }

4.7 Обработка ошибок. 
Создаем в store файл index.js. 
Тут будем описывать базовые вещи. 

export const state = () => ({
  error: null
})

export const mutations = {
  метод позволяет изменять ошибки. 
  error их state присваиваем значение переменной error
  setError(state, error) {
    state.error = error
  },
 // очищаем error из state
  clearError(state) {
    state.error = null
  }
}
// с помощью это   константы будем совершать доступ до ошибки.
// Геттер error- из state получаем state.error
export const getters = {
  error: state => state.error
}


В store в auth.js: 
добавляем метод reject


export const state = () => ({
  token: null
})

export const mutations = {
  setToken(state, token) {
    state.token = token
  },
  clearToken(state) {
    state.token = null
  }
}

export const actions = {
  async login({commit, dispatch}, formData) {
    try {
      const token = await new Promise((resolve, reject) => {
        setTimeout(() => resolve('mock-token'), 2000)
      })
      dispatch('setToken', token)
    } catch (e) {
      commit('setError', e, {root: true})
      throw e
    }
  },
  setToken({commit}, token) {
    commit('setToken', token)
  },
  logout({commit}) {
    commit('clearToken')
  }
}

export const getters = {
  isAuthenticated: state => Boolean(state.token)
}


Будем изменять state через mutation.
В методе catch() вызываем comit(): 

catch (e) {
  Тут вызывается setError из state/index.js 
  Сюда передается ошибка e
  Стобы setError был не локальным mutation, а из файла index.js: 
  {root: true} - смотрем этот метод в корне (index.js)
      commit('setError', e, {root: true})
      throw e // выбрасываем ошибку- чтобы в login также попали в блок catch
    }

 Нужно сообщить пользователю об ошибке. 
 Используем шаблон (layout).
 Сейчас работаем в empty.vue 
 
<script>
export default {
  computed: {
    // вычисляем переменную error- получаем ошибку из state
    // computed свойство будет изменяться только если геттер изменится-
    // это для оптимизации чтобы постоянно не пересчитывать
    error() {
      return this.$store.getters.error
    }
  },
  // функция watch- отслеживает изменение error. 
  //
  watch: {
  // следим за переменной error  
    error(value) {
      // если она меняется- выводим сообщение об ошибке
      // используем element ui
      this.$message.error(value)
    }
  }
}
</script>
 

4.8  Добавление пользователей. 

Из файла login.vue копируем в user.vue. 

Модифицируем админку. 

Файл user.vue:

<template>
  <el-form
    :model="controls"
    :rules="rules"
    ref="form"
    @submit.native.prevent="onSubmit"
  >
    <h2>Создать пользователя</h2>

    <el-form-item label="Логин" prop="login">
      <el-input v-model.trim="controls.login" />
    </el-form-item>

    <div class="mb2">
      <el-form-item label="Пароль" prop="password">
        <el-input v-model.trim="controls.password" type="password" />
      </el-form-item>
    </div>

    <el-form-item>
      <el-button
        type="primary"
        native-type="submit"
        round
        :loading="loading"
      >
        Создать
      </el-button>
    </el-form-item>
  </el-form>
</template>

<script>
export default {
  layout: 'admin',
  middleware: ['admin-auth'],
  data() {
    return {
      loading: false,
      controls: {
        login: '',
        password: ''
      },
      rules: {
        login: [
          { required: true, message: 'Введите логин', trigger: 'blur' }
        ],
        password: [
          { required: true, message: 'Введите пароль', trigger: 'blur' },
          { min: 6, message: 'Пароль должен быть не менее 6 символов', trigger: 'blur' }
        ]
      }
    }
  },
  methods: {
    onSubmit() {
      this.$refs.form.validate(async valid => {
        if (valid) {
          this.loading = true

          try {
            // formData отправляем на сервер
            const formData = {
              login: this.controls.login,
              password: this.controls.password
            }

            await this.$store.dispatch('auth/createUser', formData)
            // редирект не делаем. Выводим сообщение о добавлении
            // нового пользователя
            this.$message.success('Новый пользователь добавлен')
            //  поскольку не уходим со страницы- очищаем форму. 
            this.controls.login = ''
            this.controls.password = ''
            this.loading = false

          } catch (e) {
            this.loading = false
          }
        }
      })
    }
  }
}
</script>

<style lang="scss" scoped>
  form {
    width: 600px;
  }
</style>

В store/ auth.js  добавляем action: 

 async createUser({commit}, formData) {
    try {
      console.log('createUser', formData)
    } catch (e) {

    }

4.9  Список всех постов. 
Создадим пункт "Посты" в админке. 
Предусмотрим для возможность действий с ними. 

Воспользуемся компонентом из element ui:  table. 

Берем оттуда: custom colomn template (раздел)

Обновляем файл list.vue: 


<template>
  <el-table
    :data="posts"   // передаем в data посты. Посты возвращает метод asyncData
    // можем потом отдельно сразу использовать поля из массива: 
    // title, date, views, comments, _id
    style="width: 100%"
  >
    <el-table-column
      prop="title" // значение в колонке
      label="Название"
    />
    <el-table-column label="Дата">
      // выводим дату. Для примера- сегодняшнюю
      <template slot-scope="{row: {date}}">
        <i class="el-icon-time"></i>
          // преобразуем дату в строку
        <span style="margin-left: 10px">{{ new Date(date).toLocaleString() }}</span>
      </template>
    </el-table-column>
    <el-table-column label="Просмотры">
      // выводим из массива значение views
      <template slot-scope="{row: {views}}">
        <i class="el-icon-view"></i>
        <span style="margin-left: 10px">{{ views }}</span>
      </template>
    </el-table-column>
    <el-table-column label="Комментарии">
      <template slot-scope="{row: {comments}}">
        // берем иконки с сайта elemens ui /icons
        <i class="el-icon-message"></i>
        <span style="margin-left: 10px">{{ comments.length }}</span>
      </template>
    </el-table-column>
    <el-table-column label="Действия">
      // Получаем доступ до строки
      <template slot-scope="{row}">
        <el-button
          icon="el-icon-edit" // с картинкой
          type="primary"
          circle // круглая кнопка
          @click="open(row._id)"  // при щелчке на элементе текущей строки- вызываем 
          // метод open для открытия текущей строки и передаем ему _id текущей строки
        />
        <el-button
          icon="el-icon-delete"
          type="danger"
          circle 
          // при щелчке на элементе текущей строки- вызываем 
          // метод remove для удаления текущей строки и передаем ему _id текущей строки
          @click="remove(row._id)"
        />
      </template>
    </el-table-column>
  </el-table>
</template>

<script>
export default {
  layout: 'admin',
  middleware: ['admin-auth'],
  async asyncData({store}) {
    // вызываем action fetchAdmin из store/post.js
    const posts = await store.dispatch('post/fetchAdmin')
    return {posts} // возвращаем массив posts. Соединяем с data если она есть
  },
  methods: {
    // методы пока просто выводят информацию в консоль
    open(id) {
      console.log('open', id)
    },
    remove(id) {
      console.log('remove', id)
    }
  }
}
</script>

Создаем также в store  post.js:  

export const actions = {
  // Делаем запрос к админским постам
  // Сделаем потом еще другой метод для доступа к клиенским постам, которые выводятся в блоге
  async fetchAdmin({}) {
    return await new Promise(resolve => {
      setTimeout(() => {
        // в случае успешного обращения- возвращаем такие данные
        resolve([
          {title: 'Post 1', date: new Date(), views: 22, comments: [1, 2], _id: Math.random()},
          {title: 'Post 2', date: new Date(), views: 22, comments: [1, 2], _id: Math.random()}
        ])
      }, 1000)
    })
  }
}




-->